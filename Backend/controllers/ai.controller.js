import documentModel from "../models/document.model.js";
import flashcardModel from "../models/flashcard.model.js";
import quizModel from "../models/quiz.model.js";
import chatHistoryModel from "../models/chatHistory.model.js";
import * as geminiService from "../utils/geminiService.js";
import { findRelevantChunks } from "../utils/textChunker.js";

//@desc     Generate flashcard from document
//@route    POST /api/ai/generate-flashcard
//@access   Private
export const generateFlashcards = async (req, res, next) => {
  try {
    const { documentId, count = 10 } = req.body;

    if (!documentId) {
      return res.status(400).json({
        success: false,
        error: "Please provide documentId",
        statusCode: 400,
      });
    }

    const document = await documentModel.findOne({
      _id: documentId,
      userId: req.user.id,
      status: "ready",
    });

    if (!document) {
      return res.status(404).json({
        success: false,
        error: "Document not found or not ready",
        statusCode: 404,
      });
    }

    //Generate flashcards using Gemini
    const cards = await geminiService.generateFlashcards(
      document.extractedText,
      parseInt(count),
    );

    //save to database
    const flashcards = await flashcardModel.create({
      userId: req.user.id,
      documentId: document._id,
      cards: cards.map((card) => ({
        question: card.question,
        answer: card.answer,
        difficulty: card.difficulty,
        reviewCount: 0,
        isStarred: false,
      })),
    });

    res.status(201).json({
      success: true,
      data: flashcards,
      message: "Flashcards generated successfully",
    });
  } catch (error) {
    next(error);
  }
};

//@desc     Generate quiz from document
//@route    POST /api/ai/generate-quiz
//@access   Private
export const generateQuiz = async (req, res, next) => {
  try {
    const { documentId, numQuestions = 5, title } = req.body;

    if (!documentId) {
      return res.status(400).json({
        success: false,
        error: "Please provide documentId",
        statusCode: 400,
      });
    }

    const document = await documentModel.findOne({
      _id: documentId,
      userId: req.user.id,
      status: "ready",
    });

    if (!document) {
      return res.status(404).json({
        success: false,
        error: "Document not found or not ready",
        statusCode: 404,
      });
    }

    //Generate quiz using Gemini
    const questions = await geminiService.generateQuiz(
      document.extractedText,
      parseInt(numQuestions),
    );

    //save to database
    const quiz = await quizModel.create({
      userId: req.user.id,
      documentId: document._id,
      title: title || `${document.title} - Quiz`,
      questions: questions,
      totalQuestions: questions.length,
      userAnswers: [],
      score: 0,
    });

    res.status(201).json({
      success: true,
      data: quiz,
      message: "Quiz generated successfully",
    });
  } catch (error) {
    next(error);
  }
};

//@desc     Generate summary from document
//@route    POST /api/ai/generate-summary
//@access   Private
export const generateSummary = async (req, res, next) => {
  try {
    const { documentId } = req.body;

    if (!documentId) {
      return res.status(400).json({
        success: false,
        error: "Please provide documentId",
        statusCode: 400,
      });
    }

    const document = await documentModel.findOne({
      _id: documentId,
      userId: req.user.id,
      status: "ready",
    });

    if (!document) {
      return res.status(404).json({
        success: false,
        error: "Document not found or not ready",
        statusCode: 404,
      });
    }

    //Generate summary using Gemini
    const summary = await geminiService.generateSummary(document.extractedText);

    res.status(201).json({
      success: true,
      data: {
        documentId: document._id,
        title: document.title,
        summary,
      },
      message: "Summary generated successfully",
    });
  } catch (error) {
    next(error);
  }
};

//@desc     Chat with AI
//@route    POST /api/ai/chat
//@access   Private
export const chat = async (req, res, next) => {
  try {
    const { question, documentId } = req.body;

    if (!question || !documentId) {
      return res.status(400).json({
        success: false,
        error: "Please provide question and documentId",
        statusCode: 400,
      });
    }

    const document = await documentModel.findOne({
      _id: documentId,
      userId: req.user.id,
      status: "ready",
    });

    if (!document) {
      return res.status(404).json({
        success: false,
        error: "Document not found or not ready",
        statusCode: 404,
      });
    }

    //Get relevant chunks
    const relevantChunks = findRelevantChunks(document.chunks, question, 3);
    const chunkIndices = relevantChunks.map((chunk) => chunk.chunkIndex);

    // Get or create chat history
    let chatHistory = await chatHistoryModel.findOne({
      userId: req.user.id,
      documentId: document._id,
    });

    if (!chatHistory) {
      chatHistory = await chatHistoryModel.create({
        userId: req.user.id,
        documentId: document._id,
        messages: [],
      });
    }

    //Generate response using Gemini
    const answer = await geminiService.chatWithContext(
      question,
      relevantChunks,
    );

    //Save to chat history
    chatHistory.messages.push(
      {
        role: "user",
        content: question,
        timstamp: new Date(),
        relevantChunks: [],
      },
      {
        role: "assistant",
        content: answer,
        timstamp: new Date(),
        relevantChunks: chunkIndices,
      },
    );

    await chatHistory.save();

    res.status(201).json({
      success: true,
      data: {
        question,
        answer,
        relevantChunks: chunkIndices,
        chatHistoryId: chatHistory._id,
      },
      message: "Response generated successfully",
    });
  } catch (error) {
    next(error);
  }
};

//@desc     Explain concept
//@route    POST /api/ai/explain-concept
//@access   Private
export const explainConcept = async (req, res, next) => {
  try {
    const { documentId, concept } = req.body;

    if(!documentId || !concept) {
      return res.status(400).json({
        success: false,
        error: "Please provide documentId and concept",
        statusCode: 400,
      })
    }

    const document = await documentModel.findOne({
      _id: documentId,
      userId: req.user.id,
      status: "ready",
    });
    
    if(!document) {
      return res.status(404).json({
        success: false,
        error: "Document not found or not ready",
        statusCode: 404,
      })
    }

    // Find relevant chunks for the concept
    const relevantChunks = findRelevantChunks(document.chunks, concept, 3);
    const context = relevantChunks.map((c) => c.content).join("\n\n");

    //Generate response using Gemini
    const explanation = await geminiService.explainConcept(concept, context);

    res.status(201).json({
      success: true,
      data: {
        concept,
        explanation,
        relevantChunks: relevantChunks.map((c) => c.chunkIndex),
      },
      message: "Concept explained successfully",
    });
  } catch (error) {
    next(error);
  }
};

//@desc     Get chat history
//@route    GET /api/ai/chat-history/:documentId
//@access   Private
export const getChatHistory = async (req, res, next) => {
  try {
    const {documentId} = req.params;

    if(!documentId) {
      return res.status(400).json({
        success: false,
        error: "Please provide documentId",
        statusCode: 400,
      })
    }

    const chatHistory = await chatHistoryModel.findOne({
      userId: req.user.id,
      documentId: documentId,
    }).select('messages'); //Only retrieve the messages array

    if(!chatHistory) {
      return res.status(200).json({
        success: true,
        data: [],
        message: "No chat history found for this document",
      })
    }

    res.status(200).json({
      success: true,
      data: chatHistory.messages,
      message: "Chat history retrieved successfully",
    });
  } catch (error) {
    next(error);
  }
};
